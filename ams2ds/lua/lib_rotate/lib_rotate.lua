--[[

This is the implementation of the LibRotate class which provides useful helpers for session attribute
handling - create attributes from "setups" and merge default+specific "setups" together to create
combined attributes. It does not apply the attributes to a session on its own, it just provides the
attributes table to whatever addon uses this library.

This library is used by the sample addon sms_rotate.lua which implements automatic rotation of
session attributes whenever a race ends, or the session ends. You can also use this lib directly in
our own addons.

The "setup" table is very similar to simple attributes table, with some extra rules:
- If TrackId is set, sets 1 to ServerControlsTrack
- If VehicleModelId is set, sets 1 to ServerControlsVehicle, sets FORCE_IDENTICAL_VEHICLES to Flags
- If VehicleClassId is set, sets 1 to ServerControlsVehicleClass, sets FORCE_SAME_VEHICLE_CLASS to Flags
- If MultiClassSlots and VehicleClassId are set, sets 1 to ServerControlsVehicleClass, sets FORCE_MULTI_VEHICLE_CLASS to Flags
- These ServerControls* attributes and FORCE_* flags are in exclusive control of the library and
  can't be included in the setups directly.

When contructing a LibRotate instance, pass the default setup to the object. This is the setup
that will be used as the base setup by other functions.

The methods this class provides are:
- verify_setup( setup ): Check that the setup is valid - the arguments are all valid tracks/vehicles/classes/attributes.
                         Also if the setup is not the default setup, the attributes must not contain any extras (only
                         overrides are allowed), and RemoveFlags is allowed as a special argument.
- merge_setup( setup ): Verify and then combine the setup with the default setup, and return the attributes matching the merge.
- get_attributes(): Return attributes representing current merged setup.

--]]

LibRotate = {}
LibRotate.__index = LibRotate


-- Constructor
-- default_setup - The default setup passed to the library
function LibRotate.new( default_setup )
	local instance = {}
	setmetatable( instance, LibRotate )
	instance._default_setup = default_setup or {}
	instance._merged_attributes = {}
	if not instance:verify_setup() then
		error( "The default setup passed to LibRotate is not valid" )
	end
	instance:merge_setup( {} )
	return instance
end


-- Verify setup
-- setup - The setup to verify. If nothing is passed, verifies the default setup.
--
-- Valid setup satisfies these conditions:
-- - The setup is a table with only valid session attributes
-- - If checking external setup, only attributes that are set by the default setup can be used (track/vehicle/class can be always set)
-- - It is allowed to use string (name) values of tracks/vehicles/classes/enums/flags, as supported by the base normalization helpers
function LibRotate:verify_setup( setup )
	setup = setup or self._default_setup
	if not setup then
		print( "Verify setup: the setup is not a table" )
		return false
	end
	local internal = ( setup == self._default_setup )
	local result = true
	if not self:_verify_attribute_names( setup, internal ) then result = false end
	if not internal then
		if not self:_verify_no_extra_attributes( setup ) then result = false end
		if not self:_verify_track_id( setup ) then result = false end
	end
	return result
end


-- Merge setups
-- setup - The setup to merge with the default setup to create new session ttributes
-- Returns the combined attributes
function LibRotate:merge_setup( setup )
	setup = setup or {}
	if not self:verify_setup( setup ) then
		print( "Merge setup warning: invalid setup passed in, ignoring" )
		return nil
	end

	local attributes = { ServerControlsTrack = 0, ServerControlsVehicleClass = 0, ServerControlsVehicle = 0 }
	self:_merge_attributes( attributes, self._default_setup )
	self._merged_attributes = self:_merge_attributes( attributes, setup )
	return self._merged_attributes
end


-- Return attributes generated by last merge_setup call
function LibRotate:get_attributes()
	return self._merged_attributes
end


--- Private ---

local illegal_attributes = {
	ServerControlsSetup = true,
	ServerControlsTrack = true,
	ServerControlsVehicleClass = true,
	ServerControlsVehicle = true,
}

local extra_external_attributes = {
	TrackId = true,
	VehicleModelId = true,
	VehicleClassId = true,
	RemoveFlags = true,
}

-- Verify that all attributes have valid writable session attribute names
function LibRotate:_verify_attribute_names( attributes, internal )
	local result = true
	for k,_ in pairs( attributes ) do
		local attribute = name_to_session_attribute[ k ]
		if attribute then
			-- Known attribute. Is it writable?
			if attribute.access == "ReadOnly" then
				print( "Verify setup warning: read-only session attribute '" .. k .. "' used in the setup" )
				result = false
			end
			if illegal_attributes[ k ]then
				print( "Verify setup warning: internal session attribute '" .. k .. "' used in the setup" )
				result = false
			end
		else
			-- Unknown attribute. RemoveFlags is valid in external setups
			local is_valid_remove_flags = ( k == "RemoveFlags" ) and not internal
			if not is_valid_remove_flags then
				print( "Verify setup warning: unknown session attribute '" .. k .. "' used in the setup" )
				result = false
			end
		end
	end
	return result
end


-- Verify that all attributes are also present in default attributes ; RemoveFlags is supported as a special flag
function LibRotate:_verify_no_extra_attributes( attributes )
	local result = true
	local dattributes = self._default_setup
	for k,_ in pairs( attributes ) do
		local default_value = ( dattributes and dattributes[ k ] )
		if ( default_value == nil ) and ( extra_external_attributes[ k ] == nil ) then
			print( "Verify setup warning: session attribute '" .. k .. "' used in the external setup is not present in the default setup" )
			result = false
		end
	end
	return result
end


-- Verify that track id is valid and references track with grid size that large enough for the session
-- Note that because the session size is not fully set until the session is allocated, this is not 100% fool-proof.
function LibRotate:_verify_track_id( attributes )

	-- Get the track id. Ok if no track at all is set.
	local track_id = attributes.TrackId
	if not track_id then track_id = self._default_setup.TrackId	end
	if not track_id then
		return  true
	end

	-- Find the track. Fail if the id is invalid.
	local success, track_id_value = pcall( normalize_track, track_id )
	if not success or not track_id_value then
		print( "Verify setup warning: Invalid track id '" .. track_id .. "' used in the setup" )
		return false
	end
	local track = id_to_track[ track_id_value ]
	if not track then
		print( "Verify setup warning: Unknown track id '" .. track_id .. "' used in the setup" )
		return false
	end

	-- Estimate the grid size. Note that while the session is not running, this is not reliable. But it's a good upper limit.
	local grid_size = 32 -- current the game will never ask for more than this
	if server.max_player_count > 0 and server.max_player_count < grid_size then grid_size = server.max_player_count end
	if session.max_member_count > 0 and session.max_member_count < grid_size then grid_size = session.max_member_count end
	if session.next_attributes.GridSize > 0 and session.next_attributes.GridSize < grid_size then grid_size = session.next_attributes.GridSize end
	if session.attributes.GridSize > 0 and session.attributes.GridSize < grid_size then grid_size = session.attributes.GridSize end

	--print( "Grid size is " .. grid_size .. ", track '" .. track.name .. "' size is " .. track.gridsize )
	if track.gridsize < grid_size then
		print( "Verify setup warning: Track '" .. track.name .. "' (id " .. track.id .. ") has grid size limited to " .. track.gridsize ..
			", while the session's size will most likely be configured to " .. grid_size .. ". The server might end up choosing a different track instead!" )
		-- But do not fail because of this return false
	end

	return true
end


-- Merge setup into given attributes.
function LibRotate:_merge_attributes( attributes, setup )
	attributes = attributes or {}
	setup = setup or {}
	local flags = attributes.Flags or 0
	for k,v in pairs( setup ) do
		if k == "TrackId" then
			local track = id_to_track[ normalize_track( v ) ]
			if track then
				attributes.ServerControlsTrack = 1
				attributes.TrackId = track.id
			end
		elseif k == "VehicleModelId" then
			local vehicle = id_to_vehicle[ normalize_vehicle( v ) ]
			if vehicle then
				attributes.ServerControlsVehicle = 1
				attributes.ServerControlsVehicleClass = 0
				attributes.VehicleModelId = vehicle.id
				attributes.VehicleClassId = name_to_vehicle_class[ vehicle.class ].id
				flags = flags & ~SessionFlags.FORCE_MULTI_VEHICLE_CLASS
				flags = flags & ~SessionFlags.FORCE_SAME_VEHICLE_CLASS
				flags = flags | SessionFlags.FORCE_IDENTICAL_VEHICLES
			end
		elseif k == "VehicleClassId" then
			local class = id_to_vehicle_class[ normalize_vehicle_class( v ) ]
			if class and ( attributes.ServerControlsVehicle == 0 ) then
				attributes.ServerControlsVehicle = 0
				attributes.ServerControlsVehicleClass = 1
				attributes.VehicleClassId = class.id
				flags = flags & ~SessionFlags.FORCE_IDENTICAL_VEHICLES
				if attributes.MultiClassSlots and attributes.MultiClassSlots > 0 then
					-- print("Multiclass slots are set. Setting MULTI. " .. attributes.MultiClassSlots )
					flags = flags & ~SessionFlags.FORCE_SAME_VEHICLE_CLASS
					flags = flags | SessionFlags.FORCE_MULTI_VEHICLE_CLASS
				else
					-- print("No multiclass slots are set. Setting SAME. ")
					flags = flags & ~SessionFlags.FORCE_MULTI_VEHICLE_CLASS
					flags = flags | SessionFlags.FORCE_SAME_VEHICLE_CLASS
				end
			end
		elseif k == "Flags" then
			local f = normalize_session_flags( SessionFlags, v )
			if f & SessionFlags.FORCE_IDENTICAL_VEHICLES ~= 0 then
				print("[lib_rotate] Ignoring FORCE_IDENTICAL_VEHICLES flag")
			end 
			if f & SessionFlags.FORCE_SAME_VEHICLE_CLASS ~= 0 then
				print("[lib_rotate] Ignoring FORCE_SAME_VEHICLE_CLASS flag")
			end
			if f & SessionFlags.FORCE_MULTI_VEHICLE_CLASS ~= 0 then
				print("[lib_rotate] Ignoring FORCE_MULTI_VEHICLE_CLASS flag")
			end
			f = f & ~( SessionFlags.FORCE_IDENTICAL_VEHICLES | SessionFlags.FORCE_SAME_VEHICLE_CLASS | SessionFlags.FORCE_MULTI_VEHICLE_CLASS )
			flags = flags | f	
		elseif k == "RemoveFlags" then
			local f = normalize_session_flags( SessionFlags, v )
			f = f & ~( SessionFlags.FORCE_IDENTICAL_VEHICLES | SessionFlags.FORCE_SAME_VEHICLE_CLASS | SessionFlags.FORCE_MULTI_VEHICLE_CLASS )
			flags = flags & ~f
		elseif k == "MultiClassSlots" then
			if v then 
				if v > 0 then
					attributes.ServerControlsVehicle = 0
					attributes.ServerControlsVehicleClass = 1
					flags = flags & ~SessionFlags.FORCE_SAME_VEHICLE_CLASS
					flags = flags | SessionFlags.FORCE_MULTI_VEHICLE_CLASS
				else
					if attributes.VehicleClassId == nil or attributes.VehicleClassId == 0 then
						attributes.ServerControlsVehicleClass = 0
					end
					flags = flags & ~SessionFlags.FORCE_MULTI_VEHICLE_CLASS
				end
				attributes[ k ] = normalize_session_attribute( k, v )
			end
		elseif k == "MultiClassSlot1" or k == "MultiClassSlot2" or k == "MultiClassSlot3" or k == "MultiClassSlot4" then
			local class = id_to_vehicle_class[ normalize_vehicle_class( v ) ]
			if class then
				attributes[ k ] = class.id
			end
		else
			attributes[ k ] = normalize_session_attribute( k, v )
		end
	end
	attributes.Flags = flags
	return attributes
end


-- EOF --
